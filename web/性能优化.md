# 性能优化

<https://juejin.im/post/5e7723636fb9a07cc321675d>

大致可以划分为几类：度量标准、编码优化、静态资源优化、交付优化、构建优化、性能监控。

## 1. 度量标准与设定目标

在进行性能优化之前，我们需要为应用选择一个正确的度量标准（性能指标）以及设定一个合理的优化目标。

## 2. 编码优化

涉及到应用的运行时性能

### 2.1 数据读取速度

- **字面量与局部变量**的访问速度最快，数组元素和对象成员相对较慢
- 变量从局部作用域到全局作用域的搜索过程越长速度越慢
- 对象**嵌套的越深**，读取速度就**越慢**
- 对象在原型链中存在的位置越深，找到它的速度就越慢

### 2.2 DOM

DOM操作的代价非常昂贵

- 在JS中对DOM进行访问的代价非常高。请**尽可能减少访问DOM的次数**（建议缓存DOM属性和元素、把DOM集合的长度缓存到变量中并在迭代中使用。读变量比读DOM的速度要快很多。）
- 重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，**建议先让元素脱离文档流，处理完毕后再让元素回归文档流**，这样浏览器只会进行两次重排与重绘（脱离时和回归时）。
- 善于使用**事件委托**

### 2.3 流程控制

- **避免使用`for...in`**（它能枚举到原型，所以很慢）
- 在JS中倒序循环会略微提升性能
- 减少迭代的次数
- **基于循环的迭代比基于函数的迭代快**8倍
- **用Map**表代替大量的if-else和switch会提升性能

## 3. 静态资源优化

### 3.1 使用Brotli或Zopfli进行纯文本压缩

### 3.2 图片优化

尽可能通过`srcset`，`sizes`和`<picture>`元素使用响应式图片。还可以通过`<picture>`元素使用WebP格式的图像。

[图像优化原理](https://github.com/berwin/Blog/issues/28)

## 4. 交付优化

交付优化指的是对页面加载资源以及用户与网页之间的交付过程进行优化。

### 4.1 异步无阻塞加载JS

将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS。

有多种无阻塞加载JS的方法：defer、async、动态创建script标签、使用XHR异步请求JS代码并注入到页面。

但更推荐的做法是使用defer或async。如果使用defer或async请将Script标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。

### 4.2 使用`Intersection Observer`实现懒加载

懒加载是一个比较常用的性能优化手段，下面列出了一些常用的做法：

可以通过`Intersection Observer`延迟加载图片、视频、广告脚本、或任何其他资源。
可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。

### 4.3 优先加载关键的CSS

CSS资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成`<head>`标签中CSS的加载与解析之后才会渲染页面。如果CSS文件过大，用户就需要等待很长的时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的CSS提取出来内嵌到`<head>`中，然后再将剩余部分的CSS用异步的方式加载。

### 4.4 资源提示（Resource Hints）

帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。

### 4.5 Preload

通过一个现有元素（例如：img，script，link）声明资源会将获取与执行耦合在一起。然而应用可能只是想要先获取资源，当满足某些条件时再执行资源。

Preload提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。因此，Preload可以构建自定义的资源加载与执行。

例如，应用可以使用Preload进行CSS资源的预加载、并且同时具备：高优先级、不阻塞渲染等特性。然后应用程序在合适的时间使用CSS资源：

### 4.6 快速响应的用户界面

解决方案是可以将一个大任务拆分成多个小任务分布在不同的Macrotask中执行（通俗的说是将大的JS任务拆分成多个小任务异步执行）。或者使用WebWorkers，它可以在UI线程外执行JS代码运算，不会阻塞UI线程，所以不会影响用户体验。

## 5. 构建优化

### 5.1 使用预编译

### 5.2 使用 Tree-shaking、Scope hoisting、Code-splitting

Tree-shaking是一种在构建过程中清除无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。
目前Webpack与Rollup都支持Scope Hoisting。它们可以检查import链，并尽可能的将散乱的模块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了一次的模块才会被合并。使用Scope Hoisting可以让代码体积更小并且可以降低代码在运行时的内存开销，同时它的运行速度更快。前面2.1节介绍了变量从局部作用域到全局作用域的搜索过程越长执行速度越慢，Scope Hoisting可以减少搜索时间。
code-splitting是Webpack中最引人注目的特性之一。此特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。code-splitting可以用于获取更小的bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。

### 5.3 服务端渲染（SSR）

服务端渲染（Server Side Render，简称SSR）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。

### 5.4 使用import函数动态导入模块

使用import函数可以在运行时动态地加载ES2015模块，从而实现按需加载的需求。

### 5.5 使用HTTP缓存头

正确设置`expires`，`cache-control`和其他HTTP缓存头。

推荐使用`Cache-control`: `immutable`避免重新验证

## 6. 其他

- HTTP2
- 使用最高级的CDN（付费的比免费的强的多）
- 优化字体
- 其他垂直领域的性能优化

## 总结

1. 编码优化(局部变量,对象嵌套深度，DOM操作，Map)
2. 静态资源优化(压缩)
3. 异步加载JS防阻塞, 懒加载
4. Preload(在合适的时间使用CSS资源)
5. 使用import函数动态导入模块
6. 使用HTTP缓存头
7. 使用CDN
8. 服务端渲染减少白屏时间
