#

><https://zhuanlan.zhihu.com/p/112010468?utm_source=wechat_session&utm_medium=social&utm_oi=760863794850197504>

- HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。
- HTTP 协议是一个双向协议。
- HTTP 传输的内容是「超文本」。HTML 就是最常见的超文本了

HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

## 1 状态码

### 1.1 1xx

1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

### 1.2 2xx

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

- 「200 OK」是最常见的成功状态码，**表示一切正常**。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，**但响应头没有 body 数据**。
- 「206 Partial Content」是应用于 HTTP **分块下载或断点续传**，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

### 1.3 3xx

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「301 Moved Permanently」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「302 Moved Permanently」表示**临时重定向**，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- 「304 Not Modified」不具有跳转的含义，表示资源未修改，**重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制**。

#### 1.4.1 304

TODO

### 1.4 4xx

4xx 类状态码表示**客户端发送的报文有误**，服务器无法处理，也就是错误码的含义。

- 「400 Bad Request」表示客户端请求的报文有错误，但只是个**笼统的错误**。
- 「403 Forbidden」表示服务器**禁止访问**资源，并不是客户端的请求出错。
- 「404 Not Found」表示请求的资源在服务器上**不存在**或未找到，所以无法提供给客户端。

### 1.5 5xx

5xx 类状态码表示客户端请求报文正确，但是**服务器**处理时**内部发生了错误**，属于服务器端的错误码。

- 「500 Internal Server Error」与 400 类型，是个**笼统**通用的错误码，服务器发生了什么错误，我们并不知道。
- 「501 Not Implemented」表示客户端请求的功能**还不支持**，类似“即将开业，敬请期待”的意思。
- 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器**自身工作正常，访问后端服务器发生了错误**。
- 「503 Service Unavailable」表示**服务器当前很忙**，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

## 2 http 常见字段

### 2.1 Host

指定服务器的域名

### 2.2 Content-Length

服务器在返回数据时，会有 Content-Length 字段，表明**本次**回应的数据长度。

### 2.3 Connection

最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。

HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。

`Connection: keep-alive`

一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。

### 2.4 Content-Type

用于服务器回应时，告诉客户端，本次数据是什么格式。

客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。

`Accept: */*`

`Content-Type: text/html; charset=utf-8`
>上面的类型表明，发送的是网页，而且编码是UTF-8。

### 2.5 Content-Encoding

说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

`Accept-Encoding: gzip, deflate`
>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。

`Content-Encoding: gzip`
>表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

## 3 GET 与 POST

<https://www.zhihu.com/question/28586791>

Get 方法的含义是请求从服务器**获取**资源，这个资源可以是静态的文本、页面、图片视频等。

POST 方法，它向 URI 指定的资源**提交**数据，数据就放在报文的 body 里。

### 3.1 安全和幂等

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。



### 3.2 对比

#### 3.2.1 幂等

- `GET` 方法就是安全且幂等的,**因此可以对GET请求的数据做缓存**，浏览器，代理（如nginx），或者server端
- `POST` 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。
  - 不能随意多次执行。因此也就不能缓存。
  - POST可能有副作用，所以浏览器实现为不能把POST请求保存为书签。
  - 如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用
  - 把没有副作用的请求用POST实现，浏览器该弹框还是会弹框，对用户体验好处改善不大。
  - 将HTTP POST作为接口的形式使用时，就没有这种弹框了。

#### 3.2.2 携带数据的格式

- GET请求没有body，只有url，请求数据放在url的querystring中；
- POST请求的数据在body中
  - POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是"key1=value1&key2=value2"这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。

### 3.3 接口中的GET和POST

指通过浏览器的Ajax api，此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中

TODO

### 3.4 关于安全性

从攻击的角度，无论是GET还是POST**都不够安全**，因为HTTP本身是**明文协议**

https

一般情况下，私密数据传输用POST + body就好。

### 3.5 关于编码


## 4 HTTP 特性

HTTP 最凸出的**优点**是「简单、灵活和易于扩展、应用广泛和跨平台」。

1. **简单** HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解。
2. **灵活和易于扩展**
   - HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
   - 同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。
   - HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。

3. **应用广泛和跨平台**

缺点:

1. 无状态双刃剑
   1. 减轻服务器的负担
   2. 在完成有关联性的操作时会非常麻烦(Cookie)
2. 明文传输
3. 不安全(明文传输,不验证通信方的身份,无法证明报文的完整性)。HTTP 的安全问题，可以用 HTTPS 的方式解决

## 5 性能

HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。

### 5.1 长连接

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求

为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

### 5.2 管道网络传输

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，**不必等其回来，就可以发第二个请求出去**，可以减少整体的响应时间。

**但是服务器还是按照顺序**，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「**队头堵塞**」。

### 5.3 队头阻塞

「请求 - 应答」的模式加剧了 HTTP 的性能问题。
因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了

## 6 HTTP 与 HTTPS

HTTPS 解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。**而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程**，才可进入加密报文传输。

HTTP 的端口号是 80，HTTPS 的端口号是 443

HTTPS 协议需要向 CA（证书权威机构）申请数字证书(证明密钥是他的密钥)，来保证服务器的身份是可信的。

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- 窃听风险，比如通信链路上可以获取通信内容。
- 篡改风险，比如强制入垃圾广告，视觉污染。
- 冒充风险，比如冒充淘宝网站。

HTTPS可以很好的解决了上述的风险：

- 信息加密(**混合加密**)：交互信息无法被窃取。
- 校验机制(**摘要算法来实现完整性**)：无法篡改通信内容，篡改了就不能正常显示。
- 身份证书(**公钥放入到数字证书**)：证明淘宝是真的淘宝网。

### 6.1 混合加密

对称加密和非对称加密结合

- 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。(速度慢)
- 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。(运算速度快)

### 6.2 摘要算法

摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。

客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把**「指纹 + 明文」一同
加密**成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文,然后比对指纹

### 6.3 数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

为保证公钥不被篡改，需要借助第三方权威机构 CA，将服务器公钥放在数字证书，只要证书是可信的，公钥就是可信的。

### 6.4 HTTPS 是如何建立连接的？其间交互了什么？

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。(握手)
- 双方协商生产「会话秘钥」。(握手)
- 双方采用「会话秘钥」进行加密通信。

握手过程：

1. ClientHello,发送以下内容
   1. 支持的 SSL/TLS 协议版本
   2. 生产的随机数（Client Random），后面用于生产「会话秘钥」
   3. 客户端支持的密码套件列表，如 RSA 加密算法
2. SeverHello，回应内容如下
   1. 确认 SSL/ TLS 协议版本
   2. 服务器生产的随机数，后面用于生产「会话秘钥」
   3. 确认的密码套件列表，如 RSA 加密算法
   4. 服务器的数字证书
3. 客户端回应
   1. 首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
   2. 取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息
      1. 一个随机数（pre-master key）。该随机数会被服务器公钥加密。
      2. 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
      3. 客户端握手结束通知，表示客户端的握手阶段已经结束。
      4. 这样服务器和客户端就同时有三个随机数，各自生成本次通信的「会话秘钥」。
4. 服务器的最后回应
   1. 收到客户端的第三个随机数后，通过协商的加密算法，计算出本次通信的「会话秘钥」。
   2. 然后，向客户端发生最后的信息：
      1. 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
      2. 服务器握手结束通知，表示服务器的握手阶段已经结束。

## 7 HTTP/1.1、HTTP/2、HTTP/3 演变

### 7.1 HTTP/1.1 相比 HTTP/1.0 

- 使用 TCP 长连接
- 支持 管道（pipeline）网络传输

### 7.2 HTTP/2相比HTTP/1.1

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

改进：

1. 头部压缩
   - 如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。
2. 二进制格式
   - HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。
   - 头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。
   - 二进制格式增加了数据传输的效率
3. 数据流
   - HTTP/2 的数据包不是按顺序发送的。因此，必须要对数据包做标记，指出它属于哪个回应。
   - 每个请求或回应的所有数据包，称为一个数据流（Stream）。
   - 每个数据流都标记着一个独一无二的编号，其中规定**客户端**发出的数据流编号为**奇数**， **服务器**发出的数据流编号为**偶数**
   - 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。
4. 多路复用
   - HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
   - 解决队头阻塞，降低了延迟，大幅度提高了连接的利用率。
5. 服务器推送
   - 在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。

### 7.2 HTTP/3相比HTTP/2

**HTTP/2 主要的问题在于**：

多个 HTTP 请求在**复用一个 TCP 连接**，下层的 TCP 协议是不知道有多少个 HTTP 请求的。

所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。（丢包，就会阻塞所有的 HTTP 请求）

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**！

- UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。
- UDP 是不可靠传输的，但基于 UDP 的 `QUIC 协议` 可以实现类似 TCP 的可靠性传输。
- HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。
- QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

### 7.3 图解

![avatar](.\res\1.jpg)
