---
title: UDP和TCP
tags:
    - tcp
    - udp
---

<https://zhuanlan.zhihu.com/p/108822858?utm_source=wechat_session&utm_medium=social&utm_oi=760863794850197504>

<https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247484896&idx=1&sn=f7a351ffd19f14f8afdccb77557ca306&chksm=90320602a7458f144124f76cc78a9fd87d20c2c51e7c756fb6eccc1672116c6c3ef4bfc9098d&scene=0&xtrack=1#rd>

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## 1 UDP 和 TCP 的特点与区别

**用户数据报协议 UDP**（User Datagram Protocol）

- 是**无连接**的，尽最大可能交付
- 没有拥塞控制，具有较好的实时性，工作效率比TCP高
- **面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）
- 支持一对一、一对多、多对一和多对多的交互通信

**传输控制协议 TCP**（Transmission Control Protocol）

- 是**面向连接**的，提供可靠交付
- 有流量控制**拥塞控制**，提供**全双工**通信
- **面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
- 每一条 TCP 连接只能是点对点的（一对一）

## 2 UDP 、TCP 首部格式

TCP 的 6 种标识:

- SYN (建立联机)
- ACK (确认)
- PSH (传送)
- FIN (结束)，正常关闭连接
- RST (重置)，用来异常的关闭连接，发送rst段关闭连接时，不必等缓冲区的数据都发送出去，直接丢弃缓冲区中的数据。而接收端收到rst段后，也不必发送ack来确认。
- URG (紧急)

## 3 TCP 的三次握手

![avatar](.\res\2.webp)

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。**所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等**。

1. 第一次握手
   1. 客户端向服务器发出连接请求报文，这时报文首部中的同部位`SYN=1`，同时随机生成初始序列号 `seq=x`
   2. 此时，TCP客户端进程进入了 `SYN-SENT`（同步已发送状态）状态。
2. 第二次握手
   1. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 `ACK=1`，`SYN=1`，确认号是`ack=x+1`，同时也要为自己随机初始化一个序列号 `seq=y`
   2. 此时，TCP服务器进程进入了`SYN-RCVD`（同步收到）状态。
   3. 如果拒绝，
3. 第三次握手
   1. 客户进程收到确认后，还要向服务器给出确认。确认报文的`ACK=1`，`ack=y+1`
   2. 此时，TCP连接建立，客户端进入`ESTABLISHED`（已建立连接）状态。

### 3.1 为什么要三次握手

1. 已失效的连接请求报文段
   1. client发送了第一个连接的请求报文，但是由于网络不好，直到某个时间才到达server
   2. server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接
   3. 假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息
   4. 但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了

## 4 TCP数据的传输过程

建立连接后，两台主机就可以相互传输数据了。

TCP会话的双方都各自维护一个`发送窗口`和一个`接收窗口`。

发送方的发送缓存内的数据都可以被分为4类:

1. 已发送，已收到ACK
2. 已发送，未收到ACK
3. 未发送，但允许发送
4. 未发送，但不允许发送

其中类型2和3都属于发送窗口。

接收方的缓存数据分为3类：

1. 已接收
2. 未接收但准备接收
3. 未接收而且不准备接收

其中类型2属于接收窗口。

### 4.1 滑动机制(流量控制)

1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。ACK包含两个非常重要的信息：
   1. 一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据
   2. 二是当前的窗口大小m
2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。
3. 遵循快速重传、累计确认、选择确认等规则。
4. 发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。

## 5 TCP的四次挥手

1. 第一次挥手
   1. 客户端进程发出连接释放报文，并且停止发送数据。
   2. `FIN=1`，其序列号为`seq=u`（等于前面已经传送过来的数据的最后一个字节的序号加1）
   3. 此时，客户端进入`FIN-WAIT-1`（终止等待1）状态
2. 第二次挥手
   1. 服务器收到连接释放报文，发出确认报文，`ACK=1`，`ack=u+1`，并且带上自己的序列号`seq=v`
   2. 此时，服务端就进入了`CLOSE-WAIT`（关闭等待）状态
   3. 客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
   4. 客户端收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（终止等待2）状态
3. 第三次挥手
   1. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，`FIN=1`，`ack=u+1`
   2. 序列号为`seq=w`，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。
4. 第四次挥手
   1. 客户端收到服务器的连接释放报文后，必须发出确认，`ACK=1`，`ack=w+1`，而自己的序列号是`seq=u+1`，
   2. 此时，客户端就进入了`TIME-WAIT`（时间等待）状态。
   3. 注意此时TCP连接还没有释放，必须经过2∗∗MSL（**最长报文段寿命**）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
   4. **服务器**只要收到了客户端发出的确认，立即进入`CLOSED`状态。

### 5.1 为什么是4次挥手

**为了确保数据能够完成传输。**

### 5.2 tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送

关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。

### 5.3 客户端突然挂掉了怎么办

解决办法是在服务器端设置**保活计时器**，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。

若服务器超过2小时没收到客户的信息，他就**发送探测报文段**。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。

## 6 攻击

### 6.1 SYN（洪水）攻击

#### 6.1.1 什么是 SYN 攻击

攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。

由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS攻击。

#### 6.1.2 如何检测 SYN 攻击

当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。

#### 6.1.3 如何防御 SYN 攻击

不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）
- 时间增加最大半连接数
- 过滤网关防护SYN
- cookies技术

### 6.2 rst复位攻击

A和serverB之间建立了TCP连接。此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。

两种方式：

1. 伪装成A发过去的RST包
2. 伪装成A发过去的SYN包，正常连接时又来建新连接，B会认为A故障，B主动向A发个RST包。并在自己这端强制关掉连接

如何伪造A的包：

两个关键因素：源port和序列号

一个TCP连接都是四元组。由源IP、源port、目标IP、目标port唯一确定一个连接。
