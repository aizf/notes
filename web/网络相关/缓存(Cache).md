#

## 0 强缓存 弱缓存（协商缓存）

### 0.1 强缓存

不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。

优先级：

Pragma > Cache-Control > Expires

Exprires的值为服务端返回的数据到期时间，但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差

Cache-Control有很多属性，不同的属性代表的意义也不同。

- max-age：单位是**秒**，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
- no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜
- no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
- private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
- public：响应可以被中间代理、CDN 等缓存
- must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证

Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。

### 0.2 弱缓存

当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存

浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

Last-Modified和Etag

Last-Modified： **服务器在响应**请求时，会告诉浏览器资源的最后修改时间。

if-Modified-Since: **浏览器再次请求**服务器的时候，请求头会包含此字段

- 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
- 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

Etag**服务器响应**请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识

If-None-Match： **浏览器再次请求**服务器时，浏览器的请求报文头部会包含此字段

## 1 Web缓存

WEB缓存(cache)位于Web服务器和客户端之间。

带指纹资源(hash值): 永久缓存
非带指纹资源: 每次进行新鲜度校验

### 1.1 与缓存相关的http扩展消息头

`Expires`：指示响应内容过期的时间，格林威治时间GMT

`Cache-Control`：更细致的控制缓存的内容  `max-age`就是确定缓存的时间。不添加`Cache-Control`会对资源进行**强制缓存**

`Last-Modified`：响应中资源最后一次修改的时间

`ETag`：响应中资源的校验值，在服务器上某个时段是唯一标识的。

`Date`：服务器的时间

`If-Modified-Since`：客户端存取的该资源最后一次修改的时间，同Last-Modified。

`If-None-Match`：客户端存取的该资源的检验值，同ETag。

### 1.2 缓存（cache）生效的过程

1. 服务器收到请求时，会在`200OK`中回送该资源的`Last-Modified`和`ETag`头
2. 客户端将该资源保存在`cache`中，并记录这两个属性。
3. 当客户端需要发送相同的请求时，会在请求中携带`If-Modified-Since`和`If-None-Match`两个头。两个头的值分别是响应中`Last-Modified`和`ETag`头的值。
4. 服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回`304`响应

### 1.3 http的缓存机制

HTTP定义了3种缓存机制：

1. `Freshness`：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间;
2. `Validation`：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个`Last-Modified`回应头，缓存能够使用`If-Modified-Since`来判断是否已改变，以便判断根据情况发送请求;
3. `Invalidation`： 在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。

### 1.4 断点续传和多线程下载的原理

1. HTTP协议的GET方法，支持只请求某个资源的某一部分;
   1. 206 Partial Content 部分内容响应;
   2. Range 请求的资源范围;
   3. Content-Range 响应的资源范围;

### 1.5 分层次缓存的打包方案，这是一个建议方案

- webpack-runtime: 应用中的 webpack 的版本比较稳定，分离出来，保证长久的永久缓存
- react/react-dom: react 的版本更新频次也较低
- vendor: 常用的第三方模块打包在一起，如 lodash，classnames 基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来
- pageA: A 页面，当 A 页面的组件发生变更后，它的缓存将会失效
- pageB: B 页面
- echarts: 不常用且过大的第三方模块单独打包
- mathjax: 不常用且过大的第三方模块单独打包
- jspdf: 不常用且过大的第三方模块单独打包

因此为了更好的缓存效果以及按需加载，也有很多方案建议把所有的第三方模块进行单模块打包。

### 1.6 强缓存和协商缓存

- 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
- 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存

#### 1.6.1 怎么区分

属于强缓存控制的：

```txt
（http1.1）Cache-Control/Max-Age
（http1.0）Pragma/Expires
```

属于协商缓存控制的：

```txt
（http1.1）If-None-Match/E-tag
（http1.0）If-Modified-Since/Last-Modified
```

#### 1.6.2 Max-Age相比Expires

Expires使用的是服务器端的时间

而Max-Age使用的是客户端本地时间的计算

#### 1.6.3 E-tag相比Last-Modified

Last-Modified：

- 表明服务端的文件最后何时改变的
- 它有一个缺陷就是只能精确到1s，
- 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效

E-tag：

- 是一种指纹机制，代表文件相关指纹
- 只有文件变才会变，也只要文件变就会变，
- 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了

同时带有E-tag和Last-Modified，服务端会优先检查E-tag
